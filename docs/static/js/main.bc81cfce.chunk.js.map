{"version":3,"sources":["components/AddCategory.js","Helpers/getGifs.js","components/GifGridItem.js","components/gifGrid.js","hooks/useFechGifs.js","gifExpertApp.js","index.js"],"names":["AddCategory","setCategories","useState","inputValue","setInputValue","onSubmit","e","preventDefault","trim","length","categories","type","value","onChange","target","getGifs","category","a","url","encodeURI","fetch","resp","json","data","gifs","map","img","id","title","images","downsized_medium","GifGridItem","className","src","alt","GifGrid","loading","state","setstate","useEffect","then","imgs","setTimeout","useFechGifs","key","GifExpertApp","ReactDOM","render","document","getElementById"],"mappings":"qMAQaA,EAAc,SAAC,GAAqB,IAApBC,EAAmB,EAAnBA,cAAmB,EAIZC,mBAAS,IAJG,mBAIzCC,EAJyC,KAI7BC,EAJ6B,KA+B5C,OACI,0BAAMC,SAhBO,SAACC,GACtBA,EAAEC,iBAECJ,EAAWK,OAAOC,OAAS,IAC1BR,GAAc,SAAAS,GAAU,OAAKP,GAAL,mBAAmBO,OAC3CN,EAAc,OAYN,2BACIO,KAAK,OACJC,MAAQT,EACRU,SA9BU,SAACP,GAKxBF,EAAcE,EAAEQ,OAAOF,Y,uBClBbG,EAAO,uCAAG,WAAOC,GAAP,uBAAAC,EAAA,6DAEVC,EAFU,gDAEqCC,UAAUH,GAF/C,+DAQKI,MAAMF,GARX,cAQPG,EARO,gBAYUA,EAAKC,OAZf,uBAYJC,EAZI,EAYJA,KAIFC,EAAOD,EAAKE,KAAI,SAAAC,GAAO,IAAD,EACxB,MAAO,CACHC,GAAID,EAAIC,GACRC,MAAOF,EAAIE,MACXV,IAAG,UAAGQ,EAAIG,cAAP,aAAG,EAAYC,iBAAiBZ,QApB/B,kBAwBZM,GAxBY,4CAAH,sDCCRO,EAAc,SAAC,GAAiB,IAAhBH,EAAe,EAAfA,MAAMV,EAAS,EAATA,IAK/B,OACI,yBAAKc,UAAY,8CACd,yBAAKC,IAAKf,EAAKgB,IAAKN,IACpB,2BAAIA,KCHFO,EAAU,SAAC,GAAgB,IAAfnB,EAAc,EAAdA,SAAc,ECFZ,SAACA,GAAc,IAAD,EAEXd,mBAAS,CAC/BqB,KAAM,GACNa,SAAS,IAJwB,mBAE9BC,EAF8B,KAEvBC,EAFuB,KAyBzC,OAlBIC,qBAAU,WACNxB,EAAQC,GACPwB,MAAK,SAAAC,GAEFC,YAAW,WAELJ,EAAS,CACXf,KAAMkB,EACNL,SAAS,MAGX,UAKP,CAACpB,IAEDqB,EDpBwBM,CAAY3B,GAA/Ba,EAH2B,EAGhCN,KAAaa,EAHmB,EAGnBA,QAUhB,OACI,oCACA,wBAAIJ,UAAY,oCAAoChB,GAEnDoB,GAAW,uBAAGJ,UAAY,oCAAf,WAEX,yBAAKA,UAAU,aAEZ,4BAEQH,EAAOJ,KAAK,SAAAC,GAAG,OACX,kBAAC,EAAD,eACAkB,IAAKlB,EAAIC,IACLD,WEmBbmB,EA7Ca,WAAM,MAME3C,mBAAS,CAAC,gBANZ,mBAM3BQ,EAN2B,KAMfT,EANe,KAkB9B,OACI,oCAEA,4CACA,kBAAC,EAAD,CAAaA,cAAeA,IAE5B,6BAIA,4BAEIS,EAAWe,KAAK,SAAAT,GAAQ,OACxB,kBAAC,EAAD,CACA4B,IAAO5B,EACPA,SAAUA,U,MC/BtB8B,IAASC,OAAQ,kBAAC,EAAD,CAAcnC,OAAK,IAAKoC,SAASC,eAAe,U","file":"static/js/main.bc81cfce.chunk.js","sourcesContent":["import React, { useState } from 'react'\r\nimport PropTypes from 'prop-types'\r\n// para hacer mas rapido el componente pone rafc\r\n/*el input es una caja de texto, y el type se le pone para \r\nel tipo de dato para agregar */\r\n\r\n\r\n\r\nexport const AddCategory = ({setCategories}) => {\r\n\r\n/*creo un hook(useState) para poder enviar un valor al input\r\n*/\r\nconst [inputValue, setInputValue] = useState('')\r\n\r\nconst  handleInputChange = (e)=> {\r\n /*esta funcion recibe el (e) que es un evento que lo que \r\n hace con ese evento es cambiarlo en el onChange del input\r\n\r\n */   \r\n    setInputValue(e.target.value) ;\r\n/*esta funcion es el useState que toma el evento que se manda\r\nal onchange y lo renderiza con un nuevo valor \r\n*/\r\n}\r\nconst handleSubmit = (e)=>{\r\ne.preventDefault();\r\n\r\nif(inputValue.trim().length > 2){\r\n    setCategories(categories => [inputValue,...categories]);\r\n    setInputValue('');\r\n\r\n}\r\n\r\n}\r\n/*el handleSubmit se encarha de tomar el nuevo elemento \r\ny cargarlo dentro del formulario\r\ny el preventDefault lo que hace es tomar el elemento y evitar\r\nque se recargue el navegador\r\n*/\r\n    return (\r\n        <form onSubmit={handleSubmit}>\r\n            <input\r\n                type='text'\r\n                 value= {inputValue}\r\n                 onChange={(handleInputChange)}\r\n            />\r\n\r\n        </form>\r\n            \r\n    )\r\n}\r\n\r\nAddCategory.propTypes = {\r\nsetCategories : PropTypes.func.isRequired\r\n}\r\n/*el onChange se utiliza para poder cambiar le input\r\nagrego el input dentro de un form por eso elimino el fragment<>\r\n\r\n*/","\r\nexport const  getGifs = async( category) =>{\r\n    /* es una funcion de flecha que hace la peticion para la categotia*/\r\n        const url = `http://api.giphy.com/v1/gifs/search?q=${encodeURI(category)}&limit=10&api_key=0SgFOf26UV41dvU4u0QVSDzXs0i84zkh`\r\n    /* la constante url sale de postman,  entro a la pagina giphy \r\n    entro a la parte de search Endpoint y copio el url, esto lo pego en postman\r\n    y cuando me pide el api key lo ingreso y luego le pongo una busqueda\r\n    de algo ej rick and morty, despues que hago el send copio el url y lo pego en \r\n    esta constante*/\r\n           const resp= await fetch(url);\r\n    /*Fetch proporciona una interfaz JavaScript para acceder y manipular partes del canal HTTP, tales como peticiones y respuestas. \r\n    También provee un método global fetch() que proporciona una forma fácil y \r\n    lógica de obtener recursos de forma asíncrona por la red*/\r\n            const { data }= await resp.json();//es .json por que es el formato de la info que recibe el url\r\n      /* la constante gifs saca de la data.map un nuevo arreglo y me devuelbe\r\n      solo los datos que necesito, el id, el title y el  url\r\n      el ID es img.id por que esta alojado en img*/\r\n            const gifs = data.map(img =>{\r\n                return {\r\n                    id: img.id,\r\n                    title: img.title,\r\n                    url : img.images?.downsized_medium.url\r\n                }\r\n            })\r\n      \r\n     return gifs;\r\n     \r\n      \r\n        }","import React from 'react'\r\n\r\nexport const GifGridItem = ({title,url}) => {\r\n   \r\n   \r\n   \r\n   \r\n    return (\r\n        <div className = 'card animate__animated animate__backInDown'>\r\n           <img src={url} alt={title}/>\r\n           <p>{title}</p>\r\n        </div>\r\n    )\r\n}\r\n","import React from 'react';\r\nimport { useFechGifs } from '../hooks/useFechGifs';\r\n import { GifGridItem } from './GifGridItem';\r\n// // /*creamos un nuevo componente que reciba el html y busque \r\n// la imagen mandada en la category*/\r\n\r\n\r\nexport const GifGrid = ({category}) => {\r\n// transformo la funcion getGifs en async para poder usar el await\r\n    //  const [images, setImages] = useState([])\r\nconst {data:images, loading} = useFechGifs(category);\r\n   \r\n/*el useEfect lo que hace es que la funcion tenga una dependencia \r\npara poder inicializarce, en este caso inicializa el getGifs una sola\r\nvez por que dentro del [] lo dejo vacio\r\nsino tendria que mandar un argumento para que la vuelva a inicializar*/\r\n\r\n\r\n\r\n    \r\n    return (\r\n        <>\r\n        <h3 className = \"animate__animated animate__flash\">{category}</h3> \r\n\r\n        {loading && <p className = \"animate__animated animate__flash\">LOADING</p>}\r\n        \r\n         <div className=\"card-grid\">\r\n        \r\n            <ol>\r\n                {\r\n                    images.map( img => (\r\n                        <GifGridItem \r\n                        key={img.id}\r\n                        {...img} \r\n\r\n                        />\r\n\r\n                    ))\r\n            \r\n                }\r\n\r\n        \r\n            </ol>  \r\n        </div>\r\n        </> \r\n    )\r\n}\r\n","import { useEffect, useState } from \"react\";\r\nimport { getGifs } from \"../Helpers/getGifs\";\r\n\r\n// esto es un customHook, se puede crear con el rafc pero se \r\n// borra todo el codigo html y el ReactDOM por que no hay jsx\r\nexport const useFechGifs = (category) => {\r\n    \r\n    const [state, setstate] = useState({\r\n        data: [],\r\n        loading: true\r\n    });\r\n\r\n    useEffect(()=>{\r\n        getGifs(category)\r\n        .then(imgs =>{\r\n\r\n            setTimeout(()=> {\r\n\r\n                  setstate({\r\n                data: imgs,\r\n                loading: false\r\n            });\r\n\r\n            },3000 )\r\n\r\n          \r\n        })\r\n\r\n    }, [category])\r\n    \r\nreturn state; //regreso la data y el loading\r\n\r\n\r\n}\r\n","import React , { useState } from \"react\";\r\n\r\nimport { AddCategory } from \"./components/AddCategory\";\r\nimport { GifGrid } from \"./components/gifGrid\";\r\n\r\n\r\n\r\nexport const GifExpertApp = () => {\r\n/*a continuacion voy a crear una lista para poder mostar en pantalla\r\ncreo una constante con un arreglo*/\r\n// const categories =['One Punch','Samurai x','Dragon Ball'];\r\n/*comente la linea de arriba para poder crear abajo un hook o useState\r\npara poder crear un button donde agregue categorias con un butto*/\r\nconst [categories, setCategories] = useState(['pickle rick']);\r\n\r\n//  const handleAdd = ()=>{\r\n//  setCategories (categories => [...categories,'HunterxHunter'])\r\n// /* creo un nuevo arreglo y le agrego las propiedades anteriores del arreglo con ...(los tres puntos)\r\n// y le incorporo el nuevo nombre(HUNTERXHUNTER)\r\n// hago un nuevo callback dentro del setCategories*/\r\n\r\n// }\r\n\r\n/* el OL es una orden list donde puedo poner todas las categorias \r\nanteriores de la lista que quiero crear*/\r\n    return (\r\n        <>\r\n\r\n        <h2>GifExpertApp</h2>\r\n        <AddCategory setCategories={setCategories} />\r\n\r\n        <hr/>\r\n\r\n   \r\n\r\n        <ol> \r\n          { \r\n            categories.map( category =>(\r\n            <GifGrid\r\n            key = {category}\r\n            category={category}\r\n            />\r\n            ))\r\n          }\r\n        </ol>\r\n        </>\r\n\r\n\r\n    );\r\n    \r\n\r\n        }      \r\nexport default GifExpertApp;\r\n\r\n        /* en categories.map se recibe el arreglo\r\n        que se mapea y devuelve un nuevo arreglo, en este se agrega\r\n        el nuevo componente(GIFGIRD) que va a ser el encargado de recibir\r\n        la categoria y el key para devolver lo que se busca en una peticion\r\n        html*/","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport GifExpertApp from './gifExpertApp';\nimport './index.css';\n\n\n\n\n\nReactDOM.render( <GifExpertApp value />, document.getElementById('root'));\n\n"],"sourceRoot":""}